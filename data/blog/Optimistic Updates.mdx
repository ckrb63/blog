---
title: '낙관적 업데이트로 사용자 경험 개선하기'
date: '2023-08-19'
tags: ['React', 'UX', 'React-Query']
summary: '사용자가 어떤 조작을 수행할 때, 서버의 응답을 기다리지 않고 즉각적으로 UI에 변화를 반영하고 실패하면 롤백'
---
웹 어플리케이션을 사용할 때면, 모든 변경사항들이 서버에 저장됩니다.
그래서 우리는 브라우저를 아무때나 종료해도, 다른 PC에서 접속해도, 진행상황을 쉽게 이어갑니다.
서버와의 통신 결과를 UI에 반영하다보니 조작과 UI반영 사이에 네트워크 지연 시간이 생깁니다.
만약 자주 사용하는 기능에서 이러한 지연 시간이 계속해서 발생한다면 사용자 경험을 크게 저하시키게 됩니다.


## 낙관적 업데이트가 필요한 상황
예시를 보겠습니다. 아래의 화면은 근무표를 만드는 웹 서비스에서 각 칸에 근무를 입력하는 상황입니다. 입력할 때마다 서버에게 `PATCH` 요청을 보내고, 성공하면 칸을 채우고 있습니다.

![](https://velog.velcdn.com/images/cksrb63/post/bbab8c9f-a222-489a-8a9f-0914d4edb2ca/image.png)

지연 시간은 `103ms` 비교적 빨리 처리되긴 합니다만, 조금만 더 느려지면 어떤 사용자는 지연을 체감합니다.
![](https://velog.velcdn.com/images/cksrb63/post/e7444f87-f065-4768-848a-449510381cbf/image.png)

이번엔 한번에 많은 입력을 넣어보겠습니다. `Ctrl + V`로 여러 근무를 한번에 붙혀넣기 합니다.
![](https://velog.velcdn.com/images/cksrb63/post/b792ac88-bcb2-4ab7-952d-630ccd9548c3/image.png)


지연 시간은 `629ms`로 사용자 경험이 저하될만한 수준입니다.
![](https://velog.velcdn.com/images/cksrb63/post/ba5bb08f-7f90-4c25-93f6-093c78009b88/image.png)

## 낙관적 업데이트
`낙관적 업데이트`는 이러한 문제를 해결하기 위한 방법으로, 사용자 동작에 대한 네트워크 요청 응답을 기다리지 않고 UI를 업데이트 합니다. 
만약 요청이 실패한다면 업데이트한 부분을 롤백합니다.

낙관적 업데이트를 사용하면 원래 오래 걸리는 응답 뿐만 아니라 사용자가 처해있는 네트워크 환경이 느려져도 사용자 경험을 보장합니다.

- 즉각적인 사용자 경험 제공
- 다양한 네트워크 환경에 대비

## React Query를 사용한 낙관적 업데이트 적용 방법
서버 상태 관리를 위해 가장 많이 사용하는 `React Query`를 사용하여 근무 입력 기능에 낙관적 업데이트를 구현해 봅시다.

### 쿼리 취소
`mutate`가 발생할 때, 관련 쿼리를 취소하여 이전 서버 데이터가 낙관적 업데이트를 덮어쓰지 않도록 합니다.
```ts
await queryClient.cancelQueries(['shift']);
```
### 이전 상태 저장 및 낙관적 업데이트
현재의 상태를 저장하여 변경이 실패할 경우 원래 상태로 롤백 가능하게 합니다. 이전 상태의 데이터를 객체 형태로 return 하면 `onError`에서 `context`릉 통해 사용가능합니다. 

`mutate`단계에선 데이터가 서버에 반영되기 전임에도 불구하고, 사용자에게는 변경이 즉시 적용된 것처럼 보이게 합니다.

```ts
onMutate: async ({ focus, shiftTypeId }) => {
        await queryClient.cancelQueries(['shift']);
        const oldShift = queryClient.getQueryData<Shift>(shiftQueryKey);
        queryClient.setQueryData<Shift>(
          shiftQueryKey,
          produce(oldShift, (draft) => {
            draft.divisionShiftNurses
              .flatMap((x) => x)
              .find((x) => x.shiftNurse.shiftNurseId === focus.shiftNurseId)!.wardShiftList[
              focus.day
            ] = shiftTypeId;
          })
        );
        return { oldShift };
      },
```
### 실패시 롤백
만약 요청이 실패하면 이전에 저장한 상태로 되돌립니다. `onError`의 마지막 인수인 `context`를 사용합니다. 이것은 `onMutate
```ts
onError: (_, __, context) => {
        queryClient.setQueryData(shiftQueryKey, context.oldShift);
      },
```

### 전체 코드
```ts
const { mutate: mutateShift, status: changeStatus } = useMutation(
    ({
      wardId,
      focus,
      shiftTypeId,
    }: {
      wardId: number;
      focus: Focus;
      shiftTypeId: number | null;
    }) => updateShift(wardId, year, month, focus.day + 1, focus.shiftNurseId, shiftTypeId),
    {
      onMutate: async ({ focus, shiftTypeId }) => {
        await queryClient.cancelQueries(['shift']);
        const oldShift = queryClient.getQueryData<Shift>(shiftQueryKey);
        queryClient.setQueryData<Shift>(
          shiftQueryKey,
          produce(oldShift, (draft) => {
            draft.divisionShiftNurses
              .flatMap((x) => x)
              .find((x) => x.shiftNurse.shiftNurseId === focus.shiftNurseId)!.wardShiftList[
              focus.day
            ] = shiftTypeId;
          })
        );
        return { oldShift, oldEditHistory };
      },
      onError: (_, __, context) => {
        queryClient.setQueryData(shiftQueryKey, context.oldShift);
        setState('editHistory', context.oldEditHistory);
      },
    }
```

## 낙관적 업데이트를 사용하면 안되는 경우
모든 상황에서 낙관적 업데이트를 사용할 수 있는건 아닙니다. 구매나 금융 거래 등 중요한 데이터를 다루는 경우 데이터를 안전하게 업데이트 해야 합니다. 
실패확률이 높은 데이터를 다룰 때도 낙관적 업데이트를 사용한다면 사용자에게 혼란을 줄 수 있습니다. 아니면 데이터가 동기적으로 처리되어야 하는 경우 순서를 보장하기 위해 응답을 기다려야 할 때도 있습니다.
- 중요한 데이터를 다루는 경우
- 실패 확률이 높은 작업
- 복잡한 종속성을 가진 데이터
